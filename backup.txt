class Background : public AGLDrawable
{
public:
    Background(GLfloat xStart = -1, GLfloat yStart = 1, GLfloat xEnd = 1, GLfloat yEnd = -1);
    void setShaders();
    void setBuffers();
    void draw();
private:
    std::array<std::array<GLfloat,2>, 6> squareVertices;
};

Background::Background(GLfloat xStart, GLfloat yStart, GLfloat xEnd, GLfloat yEnd)
{

    squareVertices[0][0] = xStart;
    squareVertices[0][1] = yStart;
    squareVertices[1][0] = xEnd;
    squareVertices[1][1] = yStart;
    squareVertices[2][0] = xStart;
    squareVertices[2][1] = yEnd;
    squareVertices[3][0] = xEnd;
    squareVertices[3][1] = yEnd;
    squareVertices[4][0] = xStart;
    squareVertices[4][1] = yEnd;
    squareVertices[5][0] = xEnd;
    squareVertices[5][1] = yStart;

    setShaders();
    setBuffers();
}
void Background::setShaders()
{
    compileShaders(R"END(
                   #version 330
                   #extension GL_ARB_explicit_uniform_location : require
                   #extension GL_ARB_shading_language_420pack : require
                   layout(location = 0) in vec2 pos;
                   layout(location = 2) uniform vec3  first_color;
                   layout(location = 3) uniform vec3  second_color;
                   out vec2 pvec;
                   flat out vec3 color1;
                   flat out vec3 color2;

                   void main(void) {
                       vec2 p = pos;
                       gl_Position = vec4(p, 0.0, 1.0);
                       color1 = first_color;
                       color2 = second_color;
                       pvec = pos;
                   }
                   )END", R"END(
                          #version 330
                          flat in vec3 color1;
                          flat in vec3  color2;
                          in vec2 pvec;
                          void main(void) {
                                float total = floor(pvec.x * 5.0f) + floor(pvec.y * 5.0f);
                                bool isEven = mod(total,2.0) == 0.0;
                                 gl_FragColor = (isEven)? vec4(color1,1) : vec4(color2, 1);
                          }
                          )END");
}



void Background::setBuffers()
{
    bindBuffers();
    GLfloat temp[6][2] = {{squareVertices[0][0], squareVertices[0][1]},
                          {squareVertices[1][0], squareVertices[1][1]},
                          {squareVertices[2][0], squareVertices[2][1]},
                          {squareVertices[3][0], squareVertices[3][1]},
                          {squareVertices[4][0], squareVertices[4][1]},
                          {squareVertices[5][0], squareVertices[5][1]}};
    glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), temp, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(
            0,                 // attribute 0, must match the layout in the shader.
            2,                  // size
            GL_FLOAT,           // type
            GL_FALSE,           // normalized?
            0,//24,             // stride
            (void*)0            // array buffer offset
    );
}

void Background::draw()
{
    bindProgram();
    bindBuffers();
    glUniform3f(2, 1.0, 1.0, 1.0);
    glUniform3f(3, 0.0, 0.0, 0.0);
    glDrawArrays(GL_TRIANGLES, 0, 6);
}
